{"version":3,"sources":["codenames/state.cljs"],"mappings":";;;;;;AAMA,AAAA,AAEA,AAEA,AAAA,AAAMA;AAAN,AAAkB,AAACC,AAAM,AAAA,AAACC,AAAYC,AAAc,AAAGC;;AAEvD,AAGA,AAAA,AAAMC,AAAcC;AAApB,AAA0B,AAAA,AAACJ,AAAYC,AAAeG;;AAEtD,AAMA,AAAA,AAAMC,AAAmBC;AAAzB,AACE,AAACC,AAAK,AAACC,AACD,AAACC,AACA,AAAKC,AAAMC;AAAX,AAAA,AAAA,AAAA,AAAA,AAAA,AACGD,AACa,AAACE,AAAeD;AAEhCL;;AAET,AAAA,AAAA,AAAAO,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD;AAAN,AACM,AAACE,AAAU,AAACnB;;;AADlB,AAAA,AAAA,AAAMiB,AAEFX;AAFJ,AAAA,AAAA,AAAA,AAAA,AAAA,AAEuBA,AAAgB,AAACC,AAAkB,AAACF,AAAaC;;;AAFxE,AAAA,AAAA,AAAMW;;AAAN,AAIA,AAAA,AAAAG,AAAAC,AAAAC;AAAA;AAAA,AAAA,AAASC,AAAM,AAACC,AAAQ,AAACL;;AAEzB,AAAKM,AAAY,AAAA,AAAA,AAACC,AAAUH;AAC5B,AAAKI,AAAuB,AAAA,AAAA,AAACD,AAAUH;AACvC,AAAA,AAAMK,AAAahB;AAAnB,AAA0B,AAAA,AAAA,AAACc,AAAUH,AAAkBX;;AAEvD,AAAA,AAAMiB;AAAN,AACE,AAACC,AAAOP,AAAM,AAACJ;;AAEjB,AAAA,AAAMY,AAAUzB;AAAhB,AACE,AAACwB,AAAOP,AAAM,AAACJ,AAAUb;;AAE3B,AAAA,AAAM0B,AAAUC;AAAhB,AACE,AAAA,AAAA,AAAA,AAAAC,AAAA,AAACC,AAAMZ,AAAMa,AAAsBT,AAAoCM;;AACvE,AAAA,AAACH,AAAOH","names":["codenames.state/new-seed","cljs.core/first","codenames.random/sample","codenames.words/words","js/Date","codenames.state/select-words","seed","codenames.state/generate-word-map","words","cljs.core.into","cljs.core/sorted-map","cljs.core.map_indexed","index","word","clojure.string/upper-case","var_args","G__29027","codenames.state/new-state","js/Error","codenames.state.new_state","js/codenames","js/codenames.state","js/codenames.state.state","codenames.state/state","reagent.core.atom","codenames.state/seed-cursor","reagent.core/cursor","codenames.state/controlled-word-cursor","codenames.state/word-cursor","codenames.state/random-seed","cljs.core/reset!","codenames.state/set-seed","codenames.state/set-team","team","cljs.core/deref","cljs.core.swap_BANG_","cljs.core/assoc-in"],"sourcesContent":["(ns codenames.state\n  (:require [reagent.core :as rc]\n            [codenames.words :as words]\n            [clojure.string :as str]\n            [codenames.random :as rand]))\n\n(declare state)\n\n(comment (words/words))\n\n(defn new-seed [] (first (rand/sample words/words 1 (. js/Date now))))\n\n(comment\n  (new-seed))\n\n(defn select-words [seed] (rand/sample words/words 25 seed))\n\n(comment\n  (select-words 5)\n  (select-words \"a\")\n  (select-words \"polic\"))\n\n\n(defn generate-word-map [words]\n  (into (sorted-map)\n        (map-indexed\n         (fn [index word]\n           [index\n            {:words/word (str/upper-case word)\n             :words/team :none}])\n         words)))\n\n(defn new-state\n  ([] (new-state (new-seed)))\n  ([seed] {:words/seed seed :words/map (generate-word-map (select-words seed)) ::controlled-word false}))\n\n(defonce state (rc/atom (new-state)))\n\n(def seed-cursor (rc/cursor state [:words/seed]))\n(def controlled-word-cursor (rc/cursor state [::controlled-word]))\n(defn word-cursor [index] (rc/cursor state [:words/map index]))\n\n(defn random-seed []\n  (reset! state (new-state)))\n\n(defn set-seed [seed]\n  (reset! state (new-state seed)))\n\n(defn set-team [team]\n  (swap! state assoc-in [:words/map @controlled-word-cursor :words/team] team)\n  (reset! controlled-word-cursor nil))\n\n"]}