{"version":3,"sources":["codenames/random.cljs"],"mappings":";;;AAGA,AAAKA,AAAQ,AAAA,AAAA,AAACC;AACd,AAAA,AAAKC;AACL,AAAA,AAAKC;AAEL,AAAA,AAAMC,AAAMC;AAAZ,AACE,AAACC,AAAI,AAAG,AAAGJ,AAAWG,AAAIF,AAAWH;;AAEvC,AAAA,AAAMO,AACHC,AAAKC;AADR,AAEE,AAAMC,AAAQ,AAACN,AAAKI;AACdG,AAAI,AAAIF,AAAM,AAACH,AAAII,AAAQD,AAAOC;AADxC,AAEE,AAAAE,AAAA,AAAA;AAAA,AAAU,AAACC,AAAKF,AAAI,AAACJ,AAAAA,AAAAA,AAAgBG,AAAAA,AAAQD,AAAAA;AAA7C,AAAA;;AAEJ,AAAA,AAAMK,AAAWN,AAAKC;AAAtB,AAA6B,AAACF,AAAgBC,AAAKC;;AAEnD,AAMA,AAAA,AAAMM,AAAaP;AAAnB,AACE,AAAI,AAASA;AACX,AAACQ,AAAK,AAACC,AAAeT;;AACtBA;;;AAEJ,AAGA,AAAA,AAAMU,AAAQC,AAAWC,AAAOZ;AAAhC,AACE,AAAOa,AAAI,AAACP,AAAU,AAACC,AAAYP,AAAM,AAAA,AAAK,AAACc,AAAMH;AAArD,AACOI;AADP,AAEOC;;AAFP,AAGE,AAAI,AAACC,AAAE,AAACH,AAAME,AAASJ;AACrB,AAAA,AAACO;AAADD;AAAA,AAAM,AAAAA,AAACE,AAAIT;;AAAcI;;AACzB,AAAAM,AAA0BR;AAA1BS,AAAA,AAAAC,AAAAF;AAAAG,AAAA,AAAAC,AAAAH;AAAAA,AAAA,AAAAI,AAAAJ;AAAAE,AAAOG;AAAPL,AAAiBM;AACXC,AAAmB,AAACb,AAAAA,AAAAA,AAAQW,AAAAA;AADlC,AAEE,AAAIE;AACF,AAAOD;AAAQb;AAAQC;;;;;;AACvB,AAAOY;AAAQ,AAACE,AAAKf,AAAQY;AAAS,AAACG,AAAKd,AAAQW;;;;;;;;;;AAE9D","names":["codenames.random/modulus","Math/pow","codenames.random/multiplier","codenames.random/increment","codenames.random/step","in","cljs.core/mod","codenames.random/random-lazy-seq","seed","limit","stepped","out","cljs.core/LazySeq","cljs.core/cons","codenames.random/generator","codenames.random/coerce-seed","cljs.core/hash","clojure.string/lower-case","codenames.random/sample","collection","amount","gen","cljs.core/count","indices","sampled","cljs.core._EQ_","p1__26429#","cljs.core.map","cljs.core.nth","vec__26433","seq__26434","cljs.core/seq","first__26435","cljs.core/first","cljs.core/next","next-rn","rest-rn","already-generated?","cljs.core.conj"],"sourcesContent":["(ns codenames.random\n  (:require [clojure.string :as str]))\n\n(def modulus (Math/pow 2 32))\n(def multiplier 134775813)\n(def increment 1)\n\n(defn step [in]\n  (mod (+ (* multiplier in) increment) modulus))\n\n(defn random-lazy-seq\n  [seed limit]\n  (let [stepped (step seed)\n        out (if limit (mod stepped limit) stepped)]\n    (lazy-seq (cons out (random-lazy-seq stepped limit)))))\n\n(defn generator [seed limit] (random-lazy-seq seed limit))\n\n(comment\n  (step 5)\n  (step (step 5))\n  (take 2 (generator 5 nil))\n  (take 2 (generator 5 5)))\n\n(defn coerce-seed [seed]\n  (if (string? seed)\n    (hash (str/lower-case seed))\n    seed))\n\n(comment\n  (hash \"abc\"))\n\n(defn sample [collection amount seed]\n  (loop [gen (generator (coerce-seed seed) (dec (count collection)))\n         indices []\n         sampled #{}]\n    (if (= (count sampled) amount)\n      (map #(nth collection %) indices)\n      (let [[next-rn & rest-rn] gen\n            already-generated? (sampled next-rn)]\n        (if already-generated?\n          (recur rest-rn indices sampled)\n          (recur rest-rn (conj indices next-rn) (conj sampled next-rn)))))))\n\n(comment\n  (let [l (range 0 10)]\n    [(sample l 2 5)\n     (sample l 3 5)\n     (sample l 4 5)\n     (sample l 4 6)\n     (sample l 2 \"a\")\n     (sample l 5 \"a\")\n     (sample l 5 1455541201)])\n  (sample (range 10) 2 6)\n  (range 10)\n  10)\n"]}